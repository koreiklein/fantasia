Copyright (C) 2013 Korei Klein <korei.klein1@gmail.com>

SUMMARY:
  Fantasia is an interactive proof tool containing an embedded program extraction engine.

  As a proof tool, fantasia is designed to provide the most pleasant possible user experience.
  In fantasia's user experience, a human user makes use of fantasia to state Formulas and
  construct Proofs of those formulas.

  Using an extraction engine, fantasia can convert proofs into programs and run them.
  Therefore, fantasia can be used both as a tool for reasoning and as an environment for
  software creation.

  By achieving excellence in the two roles of a) the experience of proving and b) the extraction
  of high quality programs, fantasia aims to distinguish itself from other software projects.

CODE OVERVIEW:
  The code for the fantasia project is organized hierarchically into python modules.
  Three of the most central modules are the ui, calculus, and extraction modules.
    calculus: This module defines python objects to represent programs and proofs.
    ui: This module defines functions for rendering certain objects defined
        in the calculus module.  It also defines mechanisms for the user to interact
        with with those objects, examining them and constructing proofs.
    extraction: This module has one submodule for each extraction engine.
                Each extraction engine defines a way to convert proofs into programs.

  These three modules form the "bridge" between the user and the machines that run
  his software as shown in the below diagram:
            ____________________   ___________________   ______________________
            |                  |   |                 |   |                    |
  Machines--|   extraction:    |---|   calculus:     |---|    ui:             |--User
            |     compilers    |   |    programs     |   |     interaction    |
            |     interpreters |   |    proofs       |   |     rendering      |
            --------------------   -------------------   ----------------------

DESCRIPTIONS OF FANTASIA'S MODULES:

  THE CALCULUS MODULE:
    The calculus module contains two submodules, calculus.basic and calculus.enriched.
    Each of these two modules defines a logical calculus that is used to represent proofs.
    Each calculus can be thought of as a category consisting of
      a) formulas (the objects of the category)
      b) proofs   (the arrows of the category)

    FORMULAS IN THE CALCULUS MODULE:
      A formula is a formal expression of some mathematical fact.
        Examples of formulas:
          a) Every list of natural numbers can be sorted
          b) Every natural number is greater than or equal to zero.
          c) p is a prime number.
          d) p is a prime number AND p >= 10
          e) n is the length of the list l.
          f) It is not the case that a < b
      Formulas can be built from each other by means of logical combinators.
        For example, the AND combinators
          (e.g. calculus.basic.Conj(type = andType, ...), calculus.enriched.Conj(type = andType, ...))
        are used to form the logical "and" of other formulas.

    PROOFS IN THE CALCULUS MODULE:
      A proof is a formal expression of a reason why one mathematical fact (the "source" or src
      of the proof), follows logically from another mathematical fact (the "target" or tgt of the
      proof).
        Examples of proofs:

             SOURCE:                                     TARGET:
          a) (p is a prime number AND p >= 10)   ----->  (p >= 10 AND p is a prime number)
          b) (p >= 10 AND p is a prime number )  ----->  (p >= 10)
          c) (p >= 10)                           ----->  (p >= 5)
          d) (l is a list of natural numbers)    ----->  (There exists a permutation p which when
                                                          applied to l yields a list of natural
                                                          numbers in sorted order)
      Proofs can be built from one another using:
        a) composition
            For example:
              Proofs a) and b) above can be composed to yield a proof:
                (p is a prime number AND p >= 10)   ----->  (p >= 10)
        b) the "functorial" nature of the logical combinators
            For example:
              Proof c) can be applied to the right side of formula d) to yield a proof:
                (p is a prime number AND p >= 10)   ----->  (p is a prime number AND p >= 5)

    The two calculi (calculus.basic and calculus.enriched) fulfill different roles in fantasia.

    THE CALCULUS DEFINED IN CALCULUS.BASIC:
      The calculus.basic module defines a minimal representation of formulas and proofs.

      The extraction engine operates on the proofs of this calculus.  Therefore, it makes
      sense to keep the number of classes defined in calculus.basic to a minimum.
      The simpler and more primitive the calculus, the easier it is to write an extraction
      engine.

      While using fantasia, users should not have to think at all about this calculus.

    THE CALCULUS DEFINED IN CALCULUS.ENRICHED:
      The calculus.enriched module defines a calculus that extends the calculus in calculus.basic.
      This calculus is more sophisticated and can represent formulas more compactly.
      The user will think exclusively about this calculus while proving, so it is designed to
      be as user friendly as possible.

      TRANSLATION FROM CALCULUS.ENRICHED INTO CALCULUS.BASIC:
        Extraction does not operate directly on the proofs in calculus.enriched.  Instead,
        when extracting a program from a proof p in this calculus, p is first "translated" into
        a proof p' in calculus.basic, then the extraction engine is run on p' to generate
        a program.

  THE UI MODULE:
    The ui module is fairly straightforward.  It defines functions for rendering
    formulas to a screen.  It will also define what actions the user should take
    (e.g. pressing buttons, tapping a screen, ...) in order to generate proofs.

  THE LIB MODULE:
    In order to prove interesting things, the user will need to start with appropriate axioms.
    For example, a user will need a bunch of basic facts about lists, sets, and natural numbers
    to use in his proofs.

    The lib module contains various formulas of the logical calculi defined in the calculus module.
    You can think of these formulas as the libraries which the user will start with and rely
    on when performing his proofs.

  THE EXTRACTION MODULE:
    The extraction module will contain one submodule for each extraction engine.
    The module for each extraction engine must have two submodules:
      a) the arrows submodule:
          This submodule implements the conversion of the proofs of the calculus.basic
          module into program transformations.
      b) the lib submodule:
          This submodule will contain programs implementing the formulas defined in the top
          level lib module (fantasia/lib).

    The theoretical basis of program extraction is the curry-howard isomorphism.  The curry-howard
    isomorphism pairs every formula with a program and every proof with a program transformation.
    Each user of fantasia will start with a formula S defined in the lib module, and use the functions
    defined for him in the ui module to generate a proof p in the enriched calculus.
    That proof will be converted into a proof p' in the basic calculus.  The extraction engine
    defines a program s corresponding to the source (S) of p.  It will also convert the
    proof p' into a program transformation r.  It then applies the transformation r to the program
    s to get a new program t which corresponds to the target (T) of p.  This process can be
    summarized by the following commutative diagram:

    *************************************************************************************************
    | ENRICHED CALUCULUS:  Formula S  ----------------Proof p------------------> Formula T          |
    |                          .                         .                           .              |
    |                          .                         .                           .              |
    |                          .                         .                           .              |
    |                          v                         v                           v              |
    |  BASIC CALUCULUS:     Formula S' ----------------Proof p'----------------> Formula T'         |
    |                          |                         |                           |              |
    |                          |                         |                           |              |
    |                          |                         |                           |              |
    |                          v                         v                           v              |
    |  PROGRAMS:            Program s ------------Program Transformation r---->> Program t          |
    |                                                                                               |
    |                                                                                               |
    |       LEGEND ******************************************************************************   |
    |       |    S --------p--------> T          p is a proof with source S and target T        |   |
    |       |***********************************************************************************|   |
    |       |    s --------r------->> t          r is a program transformation that             |   |
    |       |                                     transforms program s into program t           |   |
    |       |***********************************************************************************|   |
    |       |    S                               S' is the translation of the enriched formula  |   |
    |       |    .                               S into a basic formula.                        |   |
    |       |    .                                                                              |   |
    |       |    V                                                                              |   |
    |       |    S'                                                                             |   |
    |       |***********************************************************************************|   |
    |       |    p                               p' is the translation of the enriched proof    |   |
    |       |    .                               p into a basic proof.                          |   |
    |       |    .                                                                              |   |
    |       |    V                                                                              |   |
    |       |    p'                                                                             |   |
    |       |***********************************************************************************|   |
    |       |    S'                              Our extraction engine defines s to be the      |   |
    |       |    |                               program corresponding to the basic formula S'. |   |
    |       |    |                                                                              |   |
    |       |    v                                                                              |   |
    |       |    s                                                                              |   |
    |       |***********************************************************************************|   |
    |       |    p'                              Our extraction engine extracts the program r   |   |
    |       |    |                               from the basic proof p'.                       |   |
    |       |    |                                                                              |   |
    |       |    v                                                                              |   |
    |       |    r                                                                              |   |
    |       *************************************************************************************   |
    |                                                                                               |
    *************************************************************************************************

  THE EXAMPLES MODULE:
    This module contains example proofs.  Ideally, each example proof should have a source
    defined in the lib module.

    Also, program extraction engines can have their own example submodules.  In such a submodule,
    the extraction engine can contain code to perform an extraction of a proof defined in the top
    level examples module.  If you're looking for an illustrative example of a program extraction,
    you should start by trying to understand one of these example extractions.  For example,
    start by trying taking a brief look at main.py, and then trying to understand what is
    happening in extraction/python/examples/easy_induction.py

RUNNING THE CODE:
  fantasia is currently in a state where it can showcase the proofs in the examples module, but
  fantasia's ui is not complete enough to allow users to actually construct any proofs themselves.

  To see the formulas and proofs in the examples module, make sure to have installed:
    make
    python
    pyOpenGL

  If you like, make some modifications to main.py.

  Then cd into fantasia/ and run the following command:
    make
